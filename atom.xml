<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lishengqi&#39;Blog</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lishengqi.gitee.io/"/>
  <updated>2020-09-07T13:27:43.147Z</updated>
  <id>http://lishengqi.gitee.io/</id>
  
  <author>
    <name>小黑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java.util.function中的函数式接口</title>
    <link href="http://lishengqi.gitee.io/posts/44837.html"/>
    <id>http://lishengqi.gitee.io/posts/44837.html</id>
    <published>2020-09-07T13:14:30.000Z</published>
    <updated>2020-09-07T13:27:43.147Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：针对与jdk1.8的新特性(流)，java.util.function包下的函数式接口的学习是必不可少的。lambda表达式的入参除了普通的入参，大部分都是以lambda表达式作为方法的入参。如{(a, b) -&gt; a + b}。本文通过我对部分函数式接口的理解以及自我测试，总结出部分函数式接口的基本使用方式。</strong></p><p><a href="https://developer.ibm.com/zh/articles/j-lo-java8streamapi/">Java 8 中的 Streams API 详解</a> 新手入门可观看Stream使用详解以及Stream的介绍。</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><h4 id="jdk1-8介绍"><a href="#jdk1-8介绍" class="headerlink" title="jdk1.8介绍"></a>jdk1.8介绍</h4><blockquote><p>@FunctionalInterface</p><p>public interface <strong>Function</strong></p><p>表示接受一个参数并产生结果的函数。</p><p>这是一个functional interface的功能方法是<code>apply(Object)</code> 。</p></blockquote><p>T -&gt; 函数接收参数的类型</p><p>R -&gt; 函数返回结果的类型</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TODO 接收T类型的参数，返回R类型的结果</span>R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Function默认的调用方式</span>Function<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> String<span class="token operator">></span> function <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>function<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出结果："FUNCTION"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UnaryOperator"><a href="#UnaryOperator" class="headerlink" title="UnaryOperator"></a>UnaryOperator</h3><h4 id="jdk1-8介绍-1"><a href="#jdk1-8介绍-1" class="headerlink" title="jdk1.8介绍"></a>jdk1.8介绍</h4><blockquote><p>@FunctionalInterface</p><p>public interface <strong>UnaryOperator</strong></p><p>extends Function&lt;T,T&gt;</p><p>表示对单个操作数产生与其操作数相同类型的结果的操作。对于操作数和结果是相同类型的情况，这是Function的<code>Function</code> 。</p><p>这是一个functional interface的功能方法是<code>Function.apply(Object)</code> 。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TODO 接收T类型的参数，返回T类型的结果</span>T <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// UnaryOperator 默认的调用方式</span><span class="token comment" spellcheck="true">// TODO 接收一个String类型的参数，返回一个String类型的值。既是生产者又是消费者</span>UnaryOperator<span class="token operator">&lt;</span>String<span class="token operator">></span> unaryOperator <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>unartOperator<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">" test "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出结果："TEST";</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h3><h4 id="jdk1-8介绍-2"><a href="#jdk1-8介绍-2" class="headerlink" title="jdk1.8介绍"></a>jdk1.8介绍</h4><blockquote><p>@FunctionalInterface</p><p>public interface <strong>BiFunction</strong></p><p>表示接受两个参数并产生结果的函数。这是<code>Function</code>的二元专业化 。</p><p>这是一个functional interface的功能方法是<code>apply(Object, Object)</code> 。</p></blockquote><p>T -&gt; 函数接收第一个参数的类型</p><p>U -&gt; 函数接收第二个参数的类型</p><p>R -&gt; 函数返回结果的类型</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TODO 接收T类型和U类型的参数，返回R类型的结果</span>R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// BiFunction 默认的调用方式</span><span class="token comment" spellcheck="true">// TODO 打印输入两个参数的字符长度</span>BiFunction<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> String<span class="token punctuation">,</span> Integer<span class="token operator">></span> biFunction <span class="token operator">=</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Integer result <span class="token operator">=</span> biFunction<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"woshi"</span><span class="token punctuation">,</span> <span class="token string">"xiaohei"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出结果：12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BinaryOperator"><a href="#BinaryOperator" class="headerlink" title="BinaryOperator"></a>BinaryOperator</h3><h4 id="jdk1-8介绍-3"><a href="#jdk1-8介绍-3" class="headerlink" title="jdk1.8介绍"></a>jdk1.8介绍</h4><blockquote><p>@FunctionalInterface</p><p>public interface BinaryOperator<t></t></p><p>extends <strong>BiFunction</strong></p><p><strong>表示对同一类型的两个操作数的操作，产生与操作数相同类型的结果</strong>。对于操作数和结果都是相同类型的情况，这是BiFunction的专业化 。</p><p>这是一个functional interface的功能方法是BiFunction.apply(Object, Object) 。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TODO 接收两个T类型的参数，返回T类型的结果</span>T <span class="token function">apply</span><span class="token punctuation">(</span>T t1<span class="token punctuation">,</span> T t2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// BinaryOperator 默认的调用方式</span><span class="token comment" spellcheck="true">// TODO 例子：拼接接收的两个String参数</span>BinaryOperator<span class="token operator">&lt;</span>String<span class="token operator">></span> binaryOperator <span class="token operator">=</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> s2<span class="token punctuation">;</span>String result <span class="token operator">=</span> binaryOperator<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出结果：“ab”；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从接口的定义来说，BiFunction比Function多了一个入参，也使得BiFunction在一些业务场景上更灵活些。但其实本质上，他们的调用方式都是使用apply()进行调用</strong></p><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><h4 id="jdk1-8介绍-4"><a href="#jdk1-8介绍-4" class="headerlink" title="jdk1.8介绍"></a>jdk1.8介绍</h4><blockquote><p>@FunctionalInterface</p><p>public interface Predicate<t></t></p><p>表示一个参数的谓词（布尔值函数）。</p><p>这是一个functional interface的功能方法是test(Object) 。</p></blockquote><p><strong>简述：Predicate表达式 &lt;==&gt; 逻辑判断语句</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TODO 接收T类型参数，返回boolean类型的结果</span><span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Predicate 默认的调用方式</span><span class="token comment" spellcheck="true">// TODO Predicate接收返回boolean类型的逻辑表达式。</span>Predicate predicate <span class="token operator">=</span> pre <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"aa"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> predicate2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><h4 id="jdk1-8介绍-5"><a href="#jdk1-8介绍-5" class="headerlink" title="jdk1.8介绍"></a>jdk1.8介绍</h4><blockquote><p>@FunctionalInterface</p><p>public interface <strong>Supplier</strong></p><p>代表结果供应商。</p><p>没有要求每次调用供应商时都会返回新的或不同的结果。</p><p>这是一个functional interface的功能方法是<code>get()</code> 。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Teacher{"name":"", "school":"", "subject":""}</span><span class="token comment" spellcheck="true">// TODO 使用Supplier函数式接口创建一个默认的Teacher对象。</span><span class="token comment" spellcheck="true">// TODO 不接受任何参数，但是返回一个类型的对象。 ==> 生产者</span>Supplier<span class="token operator">&lt;</span>Teacher<span class="token operator">></span> teacherSupplier <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    Teacher t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">setSchool</span><span class="token punctuation">(</span><span class="token string">"某市一中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span><span class="token string">"语文"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取一个默认的Teacher对象。</span><span class="token comment" spellcheck="true">// 默认信息为Teacher{"name":"张三", "school":"某市一中", "subject":"语文"}</span>teacherSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用Teacher::new创建Supplier&lt;Teacher>对象。</span>Supplier<span class="token operator">&lt;</span>Teacher<span class="token operator">></span> teacherSupplier2 <span class="token operator">=</span> Teacher<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// teacherSupplier2.get() 获取到的Teacher对象默认信息为null</span>teacherSupplier2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><h4 id="jdk1-8介绍-6"><a href="#jdk1-8介绍-6" class="headerlink" title="jdk1.8介绍"></a>jdk1.8介绍</h4><blockquote><p>@FunctionalInterface</p><p>public interface Consumer<t></t></p><p>表示接受单个输入参数并且不返回结果的操作。与大多数其他功能界面不同， Consumer预计将通过副作用进行操作。</p><p>这是一个functional interface的功能方法是accept(Object) 。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TODO 接收T类型</span><span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Consumer 默认的调用方式</span><span class="token comment" spellcheck="true">// TODO Consumer ：该函数式接口接收一个参数，但不返回任何类型的值。==>消费者</span>Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span> consumer <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>consumer<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"  consumer   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出结果："CONSUMER"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="函数式接口总结"><a href="#函数式接口总结" class="headerlink" title="函数式接口总结"></a>函数式接口总结</h3><table><thead><tr><th>接口</th><th>参数</th><th>返回类型</th><th>调用方法</th><th>描述</th></tr></thead><tbody><tr><td>Predicate<t></t></td><td>T</td><td>boolean</td><td>test(T t)</td><td>默认接收返回boolean参数类型的值</td></tr><tr><td>BinaryOperator<t></t></td><td>T</td><td>T</td><td>apply(T t1, T t2)</td><td>extends BiFunction&lt;T, T, T&gt;。接收两个T类型的参数，返回T类型的数据</td></tr><tr><td>Supplier<t></t></td><td>none</td><td>T</td><td>get();</td><td>生产者。不接受任何参数，但是返回T类型的参数</td></tr><tr><td>Consumer<t></t></td><td>T</td><td>none</td><td>accept(T t);</td><td>消费者。接收T类型的参数，但是不返回任何数据</td></tr><tr><td>UnaryOperator<t></t></td><td>T</td><td>T</td><td>apply(T t);</td><td>extends Function&lt;T, T&gt;。接收T类型的参数，返回T类型的数据</td></tr><tr><td>Function&lt;T, R&gt;</td><td>T</td><td>R</td><td>apply(T t);</td><td>接收T类型的参数，返回R类型的数据</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>T, U</td><td>R</td><td>apply(T t, U u)</td><td>接收T类型和U类型的两个参数，返回R类型的结果</td></tr></tbody></table><p><strong>总结：通过对上述的函数式接口的定义和调用方式，来达到对函数式接口的认识，也希望这篇文档能帮助读者了解lambda表达式和函数式接口。理解有误的地方麻烦指正，谢谢。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前言：针对与jdk1.8的新特性(流)，java.util.function包下的函数式接口的学习是必不可少的。lambda表达式的入参除了普通的入参，大部分都是以lambda表达式作为方法的入参。如{(a, b) -&amp;gt; a + b}。本文通过我对部分
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>项目打包成镜像</title>
    <link href="http://lishengqi.gitee.io/posts/11593.html"/>
    <id>http://lishengqi.gitee.io/posts/11593.html</id>
    <published>2020-08-28T02:29:54.000Z</published>
    <updated>2020-08-31T14:37:17.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目打包成镜像并推送至阿里云的镜像仓库</p></blockquote><p>项目打包成jar包</p><pre class="line-numbers language-bash"><code class="language-bash">$ mvn clean package -Dmaven.test.skip<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打包成功之后，首先还有比较重要的一步，编写<code>Dockerfile</code></p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">## 运行在openjdk的环境下FROM openjdk:oraclelinux8## 指定哪个文件放到docker容器中。并命名为app.jarADD target/eureka-0.0.1-SNAPSHOT.jar app.jar## 声明镜像启动的端口EXPOSE 8761##运行项目。使用java命令运行项目CMD ["java", "-jar", "/app.jar"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <a href="https://juejin.im/post/6844903966707286023">详细的Dockerfile编写指令</a></p><p>使用<code>docker build</code>命令生成docker镜像。注：该命令执行在包含<code>Dockerfile</code>的目录下。也就是项目目录下</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker build -t <span class="token punctuation">[</span>REPOSITORY<span class="token punctuation">]</span> <span class="token keyword">.</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用以下命令查看镜像信息。如<code>REPOSITORY</code>,<code>IMAGE ID</code>等</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>docker tag</code>为镜像创建一个新的标签</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker tag <span class="token punctuation">[</span>IMAGE ID<span class="token punctuation">]</span> <span class="token punctuation">[</span>NAME<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>push到阿里云镜像仓库。</p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories">查看镜像仓库地址</a> </p><pre class="line-numbers language-bash"><code class="language-bash">$ docker push <span class="token punctuation">[</span>镜像仓库地址<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>镜像仓库地址：<code>点击镜像仓库</code> -&gt; <code>公网地址</code> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;项目打包成镜像并推送至阿里云的镜像仓库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目打包成jar包&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$
      
    
    </summary>
    
    
      <category term="容器" scheme="http://lishengqi.gitee.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="http://lishengqi.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>项目中RabbitMQ的基本使用</title>
    <link href="http://lishengqi.gitee.io/posts/11424.html"/>
    <id>http://lishengqi.gitee.io/posts/11424.html</id>
    <published>2020-08-22T06:17:16.000Z</published>
    <updated>2020-08-31T14:27:30.671Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单介绍在项目中基本使用RabbitMQ，从RabbitMQ的接收和发送信息来举例</p></blockquote><h4 id="RabbitMQ的引入"><a href="#RabbitMQ的引入" class="headerlink" title="RabbitMQ的引入"></a>RabbitMQ的引入</h4><p>项目引入<code>spring cloud Bus</code>的依赖，完成项目中服务与RabbitMQ的连接</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-bus-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RabbitMQ的信息发送方"><a href="#RabbitMQ的信息发送方" class="headerlink" title="RabbitMQ的信息发送方"></a>RabbitMQ的信息发送方</h4><p>使用注入的方式使用<code>AmqpTemplate</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> AmqpTemplate amqpTemplate<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>AmqpTemplate</code>含有许多种发送消息的方式。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghzl0l51f4j30u00yh11o.jpg" alt=""></p><p>上边图中的方法为发送RabbitMQ的方式提供了多样化。我这边介绍最简单的方式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**    * @Description: 发送MQ消息    * "myQueue" -> 消息发送的目标    * "message" -> 消息    */</span>amqpTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"myQueue"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RabbitMQ的信息接收方"><a href="#RabbitMQ的信息接收方" class="headerlink" title="RabbitMQ的信息接收方"></a>RabbitMQ的信息接收方</h4><p>消息接收的三种方式。代码如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 非自动创建Queue，如果启动前没有创建Queue，会抛出 Failed to declare [myQueue]</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"myQueue"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 2. 自动创建队列Queue</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queuesToDeclare <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span><span class="token string">"myQueue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 3. Exchange和Queue绑定</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>            value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span><span class="token string">"myQueue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span><span class="token string">"myExchange"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接收RabbitMQ的消息在SpringBoot项目中使用的是<code>@RabbitListener</code>。这块的配置同样也是需要自己配置的</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghzl965igdj30d80jq0v4.jpg" alt=""></p><p>想要了解<code>@RabbitListener</code>注解中各个方法的定义请看<a href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/annotation/RabbitListener.html#bindings--">RabbitListener</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单介绍在项目中基本使用RabbitMQ，从RabbitMQ的接收和发送信息来举例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;RabbitMQ的引入&quot;&gt;&lt;a href=&quot;#RabbitMQ的引入&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="http://lishengqi.gitee.io/categories/Spring-Cloud/"/>
    
    
      <category term="RabbitMQ" scheme="http://lishengqi.gitee.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Bus 配置文件实现自动更新</title>
    <link href="http://lishengqi.gitee.io/posts/44354.html"/>
    <id>http://lishengqi.gitee.io/posts/44354.html</id>
    <published>2020-08-18T14:08:39.000Z</published>
    <updated>2020-08-19T13:12:24.018Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上篇文章中描述了使用git仓库保存项目的配置文件，其他项目通过关联配置中心，实现统一配置中心。</p><p>在生产环境中，很少通过重启项目来改变项目的配置文件的。本篇将对Spring Cloud Bus如何实现保证项目运行的过程下，改变远程git仓库中的配置文件，看下项目中是否会自动刷新这些配置呢？</p></blockquote><p>这里借用下廖师兄的图</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghvc6r33ykj31kf0u0tjj.jpg" alt=""></p><p>我们在配置中心<code>config-server</code>和<code>order</code>中添加<code>Spring Cloud Bus</code>的依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-bus-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之所以引入上述的依赖，是因为我们要通过这个依赖将项目和RabbitMQ联系起来。分别启动配置中心和product。启动成功之后，我们可以看到在RabbitMQ的<code>Queues</code>中看到我们启动的项目。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghvcbx41z3j32620r6dlt.jpg" alt=""></p><p>到了这里，我们使用RabbitMQ实现了<code>config-server</code>和<code>product</code>之间的通讯。我们修改远程git仓库的配置文件，这时候我们是不知道仓库是做了什么配置。因为仓库没通知我它改了配置文件，<code>config-server</code>获取的数据还是之前获取到的数据的。这时候，我们需要做什么呢？</p><ol><li><code>config-server</code>暴露<code>bus-refresh</code>，让远程git仓库在改变配置文件之后，调接口通知<code>config-server</code>配置中心。需要在<code>pom.xml</code>中添加配置。</li></ol><pre class="line-numbers language-yml"><code class="language-yml"># 让bus-refresh接口暴露出来management:  endpoints:    web:      exposure:        include: "*"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>远程git通知配置中心，远程git仓库的配置文件有更新。在本地命令行中模拟git向<code>config-server</code>发送通知。</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ curl -v -X POST <span class="token string">"http://localhost:8080/actuator/bus-refresh"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><strong>(坑)</strong>这时候你刷新你的uri地址发现，配置还是没有刷新出来。</li></ol><p>该怎么做配置才能被获取到呢？需要在获取配置的类上边加上<code>@RefreshScope</code>这个注解。使用<code>@RefreshScope</code>表示：告诉系统要对标注<code>@RefreshScope</code>的类进行配置刷新</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/env"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RefreshScope</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${env}"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// TODO @Value("${env}")获取配置文件中env的值 如env = "config"</span>    <span class="token keyword">private</span> String env<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/getConfig"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> env<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TODO 返回config</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次启动项目，修改配置，启动中的项目访问到修改好的配置。本地的项目实现了配置文件的自动更新</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上篇文章中描述了使用git仓库保存项目的配置文件，其他项目通过关联配置中心，实现统一配置中心。&lt;/p&gt;
&lt;p&gt;在生产环境中，很少通过重启项目来改变项目的配置文件的。本篇将对Spring Cloud Bus如何实现保证项目运行的过程下，改变远程git
      
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="http://lishengqi.gitee.io/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Bus" scheme="http://lishengqi.gitee.io/tags/Spring-Cloud-Bus/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud config</title>
    <link href="http://lishengqi.gitee.io/posts/32221.html"/>
    <id>http://lishengqi.gitee.io/posts/32221.html</id>
    <published>2020-08-18T03:36:01.000Z</published>
    <updated>2020-08-19T13:12:41.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习Spring Cloud Config</p></blockquote><p>要学习这部分的知识需要先了解配置中心的工作流程</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghvcf8cg5fj31jw0u0n6m.jpg" alt=""></p><h4 id="配置中心服务器端"><a href="#配置中心服务器端" class="headerlink" title="配置中心服务器端"></a>配置中心服务器端</h4><p>配置中心的依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-config-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置中心在启动类上边的注解</p><p><code>@EnableConfigServer</code></p><p>在启动类加上注解之后，发现项目启动有问题。</p><pre class="line-numbers language-text"><code class="language-text">If you are using the git profile, you need to set a Git URI in your configuration.  If you are using a native profile and have spring.cloud.config.server.bootstrap=true, you need to use a composite configuration.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述问题是因为，你没有配置远程的git仓库，spring配置中心的工作流程就是：远程仓库 -&gt; 配置中心 -&gt; 本地系统</p><p>配置中心配置文件配置远程git仓库</p><pre class="line-numbers language-yml"><code class="language-yml">spring:  cloud:    config:      server:        git:          uri: https://gitee.com/XXX/config-repo          username: XXX # 账户          password: XXX # 密码          basedir: /Users/XXX/workspace/microservice/config/basedir # 本地存放配置中心文件的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问远程仓库的配置文件的命名规则。例子<a href="http://localhost:8080/config-XXX.yml。XXX为自定义的名字">http://localhost:8080/config-XXX.yml。XXX为自定义的名字</a></p><pre><code>/{name}-{profiles}.yml/{label}/{name} -{profiles}. yml</code></pre><p><code>name</code>:  服务器名<br><code>profiles</code>:  环境<br><code>label</code>:   分支(branch)</p><p>注：访问配置仓库的配置信息不仅支持<code>yml</code>，还支持<code>properties</code>,<code>json</code>等配置文件格式</p><h4 id="客户端获取配置中心的配置"><a href="#客户端获取配置中心的配置" class="headerlink" title="客户端获取配置中心的配置"></a>客户端获取配置中心的配置</h4><p>首先就是引入配置中心客户端的依赖啦</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-config-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我将我的客户端的配置文件信息(数据库账户密码等)放在远程git仓库上边。这时候要怎样才能访问到config配置中心呢。通过<code>service-id</code>访问到config配置中心，获取的文件为<code>项目名</code>-<code>profile</code>.yml -&gt; (order-test.yml)。这样就能获取到仓库上边的<code>order-test.yml</code>文件了</p><pre class="line-numbers language-yml"><code class="language-yml">spring:  application:    name: order  cloud:    config:      discovery:        enabled: true        service-id: CONFIG      profile: test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候启动项目是会出问题的。</p><pre class="line-numbers language-text"><code class="language-text">Description:  Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.  Reason: Failed to determine a suitable driver class  Action:  Consider the following:      If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.      If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong>：找不到数据库的配置。需要配置数据库信息。</p><p><strong>疑问</strong>：数据库配置不是放置到配置中心上了吗？而且我们在项目中配置了配置中心，按理说应该能拿到数据库的配置的。为什么拿不到配置呢？</p><blockquote><p>首先我们项目启动先加载的是我们的配置文件<code>application.yml</code>文件。而不是先去获取配置中心的信息。</p><p><strong>解决方法</strong>：我们将配置文件的优先级提高，先通过eureka去访问config配置中心，获取到项目的配置文件之后，在执行后边的操作。</p><p><strong>操作</strong>：将<code>application.yml</code>改成<code>bootstrap.yml</code>。修改配置文件的文件名。这时候才能启动我们的项目</p></blockquote><p><strong>注：配置中心在获取文件的时候<code>order-test.yml</code>的时候会默认获取一个<code>order.yml</code>的文件。获取到两个配置文件之后在进行二者的合并</strong></p><pre class="line-numbers language-shell"><code class="language-shell">Located property source: [BootstrapPropertySource {name='bootstrapProperties-configClient'}, BootstrapPropertySource {name='bootstrapProperties-https://gitee.com/lishengqi/config-repo/order-test.yml'}, BootstrapPropertySource {name='bootstrapProperties-https://gitee.com/lishengqi/config-repo/order.yml'}]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Spring-Cloud-Config使用过程中碰到的坑"><a href="#Spring-Cloud-Config使用过程中碰到的坑" class="headerlink" title="Spring Cloud Config使用过程中碰到的坑"></a><code>Spring Cloud Config</code>使用过程中碰到的坑</h4><p><strong>坑1</strong></p><blockquote><p>个人虽解决如下问题，但是不明白为何会出现这样的情况。如果哪位大佬了解，能否告知一番</p></blockquote><pre class="line-numbers language-yml"><code class="language-yml">spring:  cloud:    config:      discovery:        service-id: config        enabled: true      profile: dev  application:    name: product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照<code>bootstrap.xml</code>配置文件中的配置，按道理来说是获取<code>config</code>服务下边的<code>product-dev.xml</code>的配置文件。但是却是显示启动错误。</p><pre class="line-numbers language-text"><code class="language-text">Description:Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver classAction:Consider the following:    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.    If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我仔细查看日志中的信息。<code>ConfigServicePropertySourceLocator</code>加载的是远程git仓库上边的<code>product-test.xml文件</code>。但是我的远程git仓库中的配置文件不叫这个名字，我将名字改掉后就能完好的启动项目了。</p><pre class="line-numbers language-text"><code class="language-text">ConfigServicePropertySourceLocator : Located environment: name=product, profiles=[test], label=null, version=e2f64f3e6dac18ce0741c3f8a1088dc17ad5706f, state=null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习Spring Cloud Config&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要学习这部分的知识需要先了解配置中心的工作流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly
      
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="http://lishengqi.gitee.io/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Config" scheme="http://lishengqi.gitee.io/tags/Spring-Cloud-Config/"/>
    
  </entry>
  
  <entry>
    <title>重构SpringBoot项目</title>
    <link href="http://lishengqi.gitee.io/posts/46268.html"/>
    <id>http://lishengqi.gitee.io/posts/46268.html</id>
    <published>2020-08-16T16:01:38.000Z</published>
    <updated>2020-08-17T15:07:40.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习微服务的过程中，需要将之前学到的SpringBoot项目重构。</p><p>个人在学习过程中参考 慕课网小马哥的 <a href="https://www.imooc.com/learn/933">Spring Boot 2.0深度实践-初遇Spring Boot</a> 这门课程是免费的。如果博客阐述不当，可以去看看小马哥的视频，大佬绝对把你教会。</p></blockquote><h4 id="1-what-（什么是重构）"><a href="#1-what-（什么是重构）" class="headerlink" title="1. what?（什么是重构）"></a>1. what?（什么是重构）</h4><p>这是借用下百度的定义</p><blockquote><p>重构（Refactoring）就是通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</p></blockquote><p><strong>个人理解：</strong>举个例子：保存用户信息的过程中，Controller层负责接收用户信息，Service层负责对用户信息进行处理，Dao层负责将用户信息保存到数据库中。当然系统中不仅只有保存用户信息的业务操作。还有用户信息修改，用户注销等等，越来越多的业务出现，系统就会变得很臃肿。</p><h4 id="2-why-（为什么要重构）"><a href="#2-why-（为什么要重构）" class="headerlink" title="2. why? （为什么要重构）"></a>2. why? （为什么要重构）</h4><p>我们将系统划分为三个模块，表示层<code>web</code>，持久层<code>persistence</code>，模型层<code>model</code>。我们将项目启动的类，与用户进行数据交互的逻辑放在web表示层，将与数据库交互的逻辑放在persistence持久层，将保存信息的实体保存在model模型层。这样就显得业务划分和结构就变得很清晰</p><h4 id="3-how-（怎么样重构）"><a href="#3-how-（怎么样重构）" class="headerlink" title="3. how? （怎么样重构）"></a>3. how? （怎么样重构）</h4><p>首先将<code>pom.xml</code>中的<code>packaging</code>改成pom</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght4zuxdz5j31km0tw7as.jpg" alt=""></p><p>创建项目中的模块。<code>右键点击项目</code> -&gt; <code>New</code> -&gt; <code>Module</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght36701m4j30z60o67by.jpg" alt=""></p><p>显示如下页面。点击<code>Next</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght36lrisyj31lo0u0wo3.jpg" alt=""></p><p>填写需要创建模块的名字。继续点击<code>Next</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght377bctdj31lo0u0adt.jpg" alt=""></p><p>如下图所示，创建好的模块的<code>pom.xml</code>中，<code>&lt;parent&gt;</code>是依赖于项目的<code>pom.xml</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght37p0h70j31iw0jw428.jpg" alt=""></p><p>将系统的业务代码迁移到相应的模块中，会发现模块中的文档样式是不一样的。这时候需要进行一些调改。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght39vwv9qj30jy0gi75n.jpg" alt=""></p><p>进入到<code>project structure</code>。点击<code>mian</code>中的<code>java</code>，在点击<code>Mark as</code>中的<code>Sources</code>。显而易见，<code>java</code>wenjianjia 变成原有项目的样子。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght3bgxpgvj310p0u00za.jpg" alt=""></p><p>如果出现想启动类上边画了个X的样子，还是选择点击右边的绿色三角的话。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght5605bz2j311o07qt97.jpg" alt=""></p><p>你将会看到下边的提示 <code>错误: 找不到或无法加载主类 FirstRefactorDemoApplication</code>。这时得找到项目的启动类进行重新启动</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght57jx15cj314a06q3zf.jpg" alt=""></p><p><strong>启动项目：找到web模块中的启动类，<code>右键</code>+<code>Run</code>启动项目。</strong></p><p>按照自己的要求将项目中的接口，实体类等迁移到各个模块之后，你是否会发现下面这种情况。项目中满屏都是红色的，那是因为，这些实体类在迁移到各个模块之后，他们之间还没有任何联系，<code>import</code>导入的依赖是找不到原来的依赖的。解决办法：通过配置的方式，将各个模块联系起来。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghtldgelmuj320n0u014x.jpg" alt=""></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.xh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>model<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>artifactId</code>：所需要依赖的模块名称</p><p><code>groupId</code>和<code>version</code>：可参照<code>pom.xml</code>文件中的<code>parent</code>中的配置。</p><p><strong>注：每次修改<code>pom.xml</code>文件都必须在文件中<code>右键</code>+<code>maven</code>+<code>reimport</code>进行重新刷新</strong></p><h4 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h4><p>打开idea的终端命令行<code>Terminal</code>。运行如下命令</p><pre class="line-numbers language-bash"><code class="language-bash">$ mvn -Dmaven.test.skip<span class="token operator">=</span>true -U clean <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现这时候项目打包出问题，显示<strong>repackage failed: Unable to find main class</strong>。无法找到主类(main class)</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghts5farc1j31v30u0113.jpg" alt=""></p><p>如果你的项目是多个模块的项目，则需要在包含启动类的(web)模块的<code>pom.xml</code>中添加如下配置。</p><p>这块配置仅针对多模块的项目配置。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>+      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>+        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.xh.product.ProductApplication<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>+      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>spring-boot-maven-plugin</code>下配置<code>configuration</code>中的配置。<code>mainClass</code>中配置项目的启动类的路径。</p><p>配置完成之后，则再次执行上边的打包命令。<strong>打包好的jar默认会放在电脑配置的仓库中。</strong></p><h4 id="引用自定义生成的jar包"><a href="#引用自定义生成的jar包" class="headerlink" title="引用自定义生成的jar包"></a>引用自定义生成的jar包</h4><p>如需要将打包好的jar给其他项目进行调用，则需要在其他项目<code>pom.xml</code>中引入。可参照我的进行配置。配置完成刷新<code>pom.xml</code>文件</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.xh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>product-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成之后，再次刷新<code>pom.xml</code>文件。这时项目就会根据下图的过程找到你的jar包并引入到项目中</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghtuqqosfdj31la0s0n9d.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在学习微服务的过程中，需要将之前学到的SpringBoot项目重构。&lt;/p&gt;
&lt;p&gt;个人在学习过程中参考 慕课网小马哥的 &lt;a href=&quot;https://www.imooc.com/learn/933&quot;&gt;Spring Boot 2.0深度实践
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://lishengqi.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="项目重构" scheme="http://lishengqi.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>抽象类和接口</title>
    <link href="http://lishengqi.gitee.io/posts/45299.html"/>
    <id>http://lishengqi.gitee.io/posts/45299.html</id>
    <published>2020-08-11T16:39:45.000Z</published>
    <updated>2020-08-31T05:22:59.506Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：当面试官在问到我这块知识点的时候，我整个人脑子只是冒出来interface和abstract这两个关键字。仅说出了接口和抽象类各自的特征，但是二者之间的异同点答得不是很好，这块知识点老是记不住，还是需要通过代码来了解比较直观。</p></blockquote><p><a href="https://www.kancloud.cn/wizardforcel/w3school-java/93723">接口和抽象类的概念以及定义</a> </p><h3 id="interface-：接口"><a href="#interface-：接口" class="headerlink" title="interface ：接口"></a>interface ：接口</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InterfaceTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 接口定义对象默认使用public static final进行定义     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TEST <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TODO 显示Public static final是多余的</span>    <span class="token comment" spellcheck="true">/**     * 接口的方法默认使用public abstarct 进行定义，并且接口的方法不能有方法体     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TODO 显示Public abstract是多余的</span>    <span class="token comment" spellcheck="true">/**     * java8 接口能定义default方法的缺省的默认方法体     * java9 接口能定义私有静态方法     * @return     */</span>    <span class="token keyword">default</span> <span class="token keyword">long</span> <span class="token function">getTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// TODO 显示Public是多余的</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="abstract-：抽象"><a href="#abstract-：抽象" class="headerlink" title="abstract ：抽象"></a>abstract ：抽象</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象类 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String abs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// TODO 无参和有参的构造器</span>    <span class="token keyword">public</span> <span class="token function">AbstractTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">AbstractTest</span><span class="token punctuation">(</span>String abc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>abs <span class="token operator">=</span> abc<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// TODO Get/Set方法</span>    <span class="token keyword">public</span> String <span class="token function">getAbs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> abs<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAbs</span><span class="token punctuation">(</span>String abs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>abs <span class="token operator">=</span> abs<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"AbstractTest{"</span> <span class="token operator">+</span>                <span class="token string">"abs='"</span> <span class="token operator">+</span> abs <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// TODO Extension methods can only be used within an interface 扩展方法只能在接口内使用</span>    <span class="token comment" spellcheck="true">// default void getString(){}  // 提示错误</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TODO 抽象方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// TODO main方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>学习过程中，可以针对类和抽象类之间的异同点，抽象类和接口之间的异同点来理解，这种方式能直观的看到三者之间的关系。</strong></p><table><thead><tr><th></th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>成员变量<div></div></td><td>能定义成员变量<div></div></td><td>接口的变量默认使用public static final定义。使得该变量不能发生修改，接口不能定义成员变量</td></tr><tr><td>构造器</td><td>能定义构造器</td><td>接口不能定义构造器</td></tr><tr><td>普通方法</td><td>能定义普通方法</td><td>接口中的方法默认使用public abstract修饰</td></tr><tr><td>静态方法</td><td>能定义静态方法</td><td>接口能定义静态方法。但静态方法不能抽象[1]</td></tr><tr><td>抽象方法</td><td>能定义抽象方法，必须使用public abstract修饰该方法</td><td>接口中定义的方法除静态方法和default修饰的方法都是抽象方法(jdk1.8)。</td></tr><tr><td>继承/实现</td><td>能实现单继承，多实现</td><td>多实现</td></tr><tr><td>定义default方法</td><td>仅能在接口中定义</td><td></td></tr><tr><td>定义main方法</td><td>能定义main方法</td><td>不能定义main方法</td></tr><tr><td>创建实例</td><td>AbstractTest absTest = new AbstractTest();</td><td>// 使用匿名类的方式InterfaceTest test = new InterfaceTest(){   @Override   // TODO 重写接口中的方法}// 使用多态的方式，将接口的实现类的实例指向接口对象也能创建接口实例InterfaceTest test = new InterfaceTestImpl();</td></tr></tbody></table><p><strong>[1]</strong>：针对静态方法在接口中不能抽象的个人理解 -&gt; 静态方法本身存在是需要方法体的，并且可以通过(类名.方法名)去调用。而抽象方法不存在方法体。</p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>个人认为：接口和抽象类的应用场景跟接口和抽象类的异同点相关的。</p><p><strong>接口</strong>：接口可以具体的阐述某种对象的行为/特征。举个例子：某个对象的增删改查的业务逻辑操作，可以使用接口去实现这些操作。大多数情况下，实现一个接口的场景比较多。</p><p><strong>抽象</strong>类：抽象类则偏向多个对象的共性或者说是多个对象同时拥有或者具备的特征/行为。比如说，人类中存在一个work()的抽象方法，老师和学生这两个对象，都是属于人类。当老师和学生这两个对象去继承人类这个父类的时候。他们就要完成这个work()的实现。老师的work()主要是授课，而学生的work()主要是学习</p><p>上述仅为个人理解，理解有误的地方希望读者进行反馈，谢谢</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：当面试官在问到我这块知识点的时候，我整个人脑子只是冒出来interface和abstract这两个关键字。仅说出了接口和抽象类各自的特征，但是二者之间的异同点答得不是很好，这块知识点老是记不住，还是需要通过代码来了解比较直观。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://lishengqi.gitee.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="抽象类" scheme="http://lishengqi.gitee.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://lishengqi.gitee.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>项目打包运行在后台</title>
    <link href="http://lishengqi.gitee.io/posts/63379.html"/>
    <id>http://lishengqi.gitee.io/posts/63379.html</id>
    <published>2020-08-08T08:45:41.000Z</published>
    <updated>2020-08-14T15:41:30.120Z</updated>
    
    <content type="html"><![CDATA[<ol><li>进入到项目的路径下，输入以下命令完成项目打包</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ mvn clean package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>打包好的项目默认在项目目录中的<code>target</code>文件夹中，</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gheuzmi1xsj30m607ygp5.jpg" alt=""></p><p>  <strong><code>target</code>中的<code>eureka-0.0.1-SNAPSHOT.jar</code>就是打包好的jar包。</strong></p><ol start="3"><li>使用java命令启动项目</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ java -jar target/eureka-0.0.1-SNAPSHOT.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    程序启动如下图(可使用<code>ctrl+c</code>断开链接)：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghev4rm6icj30vo0p4qib.jpg" alt=""></p><ol start="4"><li>使用如下命令可以使得项目在后台中启动</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">nohup</span> java -jar target/eureka-0.0.1-SNAPSHOT.jar <span class="token operator">></span> /dev/null 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    会生成后台的进程号</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghev9on2n4j30v8030gn5.jpg" alt=""></p><p>​    使用以下命令可以查看这个进程的状态和信息</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span><span class="token function">grep</span> eureka //进程名字$ <span class="token function">ps</span> -ef <span class="token operator">|</span><span class="token function">grep</span> 25746 //进程标识<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    如需”杀死”该进程</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">kill</span> -9 25746 // 26349<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;进入到项目的路径下，输入以下命令完成项目打包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ mvn clean package&lt;span aria
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://lishengqi.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://lishengqi.gitee.io/tags/java/"/>
    
      <category term="linux" scheme="http://lishengqi.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>http学习</title>
    <link href="http://lishengqi.gitee.io/posts/64520.html"/>
    <id>http://lishengqi.gitee.io/posts/64520.html</id>
    <published>2020-08-08T08:42:08.000Z</published>
    <updated>2020-08-17T15:08:16.554Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HTTP-协议始于三十年多前蒂姆·伯纳斯-李的一篇论文；"><a href="#HTTP-协议始于三十年多前蒂姆·伯纳斯-李的一篇论文；" class="headerlink" title="HTTP 协议始于三十年多前蒂姆·伯纳斯 - 李的一篇论文；"></a>HTTP 协议始于三十年多前蒂姆·伯纳斯 - 李的一篇论文；</h4><p>论文中确立了三项关键技术</p><ul><li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li><li>HTML：即超文本标记语言，描述超文本文档；</li><li>HTTP：即超文本传输协议，用来传输超文本。</li></ul><h4 id="HTTP-0-9-是个简单的文本协议，只能获取文本资源；"><a href="#HTTP-0-9-是个简单的文本协议，只能获取文本资源；" class="headerlink" title="HTTP/0.9 是个简单的文本协议，只能获取文本资源；"></a>HTTP/0.9 是个简单的文本协议，只能获取文本资源；</h4><h4 id="HTTP-1-0-确立了大部分现在使用的技术，但它不是正式标准；"><a href="#HTTP-1-0-确立了大部分现在使用的技术，但它不是正式标准；" class="headerlink" title="HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；"></a>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；</h4><ul><li>增加了 HEAD、POST 等新方法；</li><li>增加了响应状态码，标记可能的错误原因；</li><li>引入了协议版本号概念；</li><li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li><li>传输的数据不再仅限于文本。</li></ul><h4 id="HTTP-1-1-是目前互联网上使用最广泛的协议，功能也非常完善；"><a href="#HTTP-1-1-是目前互联网上使用最广泛的协议，功能也非常完善；" class="headerlink" title="HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；"></a>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；</h4><ul><li>增加了 PUT、DELETE 等新的方法；</li><li>增加了缓存管理和控制；</li><li>明确了连接管理，允许持久连接；</li><li>允许响应数据分块（chunked），利于传输大文件；</li><li>强制要求 Host 头，让互联网主机托管成为可能。</li></ul><h4 id="HTTP-2-基于-Google-的-SPDY-协议，注重性能改善，但还未普及；"><a href="#HTTP-2-基于-Google-的-SPDY-协议，注重性能改善，但还未普及；" class="headerlink" title="HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；"></a>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</h4><ul><li>二进制协议，不再是纯文本；</li><li>可发起多个请求，废弃了 1.1 里的管道；</li><li>使用专用算法压缩头部，减少数据传输量；</li><li>允许服务器主动向客户端推送数据；</li><li>增强了安全性，“事实上”要求加密通信。</li></ul><h4 id="HTTP-3-基于-Google-的-QUIC-协议，是将来的发展方向。"><a href="#HTTP-3-基于-Google-的-QUIC-协议，是将来的发展方向。" class="headerlink" title="HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。"></a>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</h4><p>``</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HTTP-协议始于三十年多前蒂姆·伯纳斯-李的一篇论文；&quot;&gt;&lt;a href=&quot;#HTTP-协议始于三十年多前蒂姆·伯纳斯-李的一篇论文；&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议始于三十年多前蒂姆·伯纳斯 - 李的一篇论文；&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://lishengqi.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http协议" scheme="http://lishengqi.gitee.io/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>使用homebrew安装openResty</title>
    <link href="http://lishengqi.gitee.io/posts/14066.html"/>
    <id>http://lishengqi.gitee.io/posts/14066.html</id>
    <published>2020-08-08T08:41:58.000Z</published>
    <updated>2020-08-18T03:05:11.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p># 使用homebrew安装openResty，出现以下报错</p><p><strong>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</strong><br>Error: Failed to download resource “openresty-openssl111–patch”<br>Download failed: <a href="https://raw.githubusercontent.com/openresty/openresty/master/patches/openssl-1.1.1f-sess_set_get_cb_yield.patch">https://raw.githubusercontent.com/openresty/openresty/master/patches/openssl-1.1.1f-sess_set_get_cb_yield.patch</a></p></blockquote><h3 id="使用homebrew安装OpenResty"><a href="#使用homebrew安装OpenResty" class="headerlink" title="使用homebrew安装OpenResty"></a>使用homebrew安装OpenResty</h3><h4 id="安装OpenResty失败原因如下"><a href="#安装OpenResty失败原因如下" class="headerlink" title="安装OpenResty失败原因如下"></a>安装OpenResty失败原因如下</h4><p>错误代码如下，显示不能访问<code>raw.githubusercontent.com</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">curl: <span class="token punctuation">(</span>7<span class="token punctuation">)</span> Failed to connect to raw.githubusercontent.com port 443: Connection refused<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原因如下：在访问<code>raw.githubusercontent.com</code>的时候，本地浏览器和系统都没有该网站的缓存。DNS解析该域名的过程如下</p><pre class="line-numbers language-bash"><code class="language-bash">本地浏览器缓存 -<span class="token operator">></span> 系统浏览器缓存 -<span class="token operator">></span> hosts文件 -<span class="token operator">></span> DNS系统<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过以上报错得知：系统下载OpenResty需要从<code>raw.githubusercontent.com</code>获取资源。但是我们访问DNS系统的过程中是存在问题的。安装失败</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>通过链接<code>raw.githubusercontent.com.ipaddress.com</code>获取网站的ip:<code>199.232.68.133</code></p><p>打开本地<code>hosts</code>文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件下添加</p><pre class="line-numbers language-bash"><code class="language-bash">199.232.68.133   raw.githubusercontent.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时候，http在访问<code>raw.githubusercontent.com</code>的过程中就访问DNS，而是直接从hosts文件中获取到源站的资源。加快系统的访问速度。</p><p>以上问题是本人参照 <a href="[http://book.tangyefei.cn/master-http/_book/chapter1-7-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BAHTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html](http://book.tangyefei.cn/master-http/_book/chapter1-7-自己动手搭建HTTP实验环境.html)">自己动手搭建HTTP实验环境</a> 遇到的问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;# 使用homebrew安装openResty，出现以下报错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection 
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://lishengqi.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="homebrew" scheme="http://lishengqi.gitee.io/tags/homebrew/"/>
    
      <category term="openResty" scheme="http://lishengqi.gitee.io/tags/openResty/"/>
    
  </entry>
  
  <entry>
    <title>mac下安装maven</title>
    <link href="http://lishengqi.gitee.io/posts/59524.html"/>
    <id>http://lishengqi.gitee.io/posts/59524.html</id>
    <published>2020-08-08T08:41:36.000Z</published>
    <updated>2020-08-14T15:42:03.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在终端使用mvn -v显示zsh: command not found: mvn</p></blockquote><p>在<a href="https://maven.apache.org/download.cgi">maven官网</a>下载maven压缩包</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghj5c1q4mqj31qq0bc40r.jpg" alt=""></p><p>下载并解压到<code>/usr/local</code>文件夹下。检查maven的目录是否和下图一致</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghj5egpiayj316s0o8k3g.jpg" alt=""></p><p><strong>注：如果maven文件不存在<code>bin</code>目录，会导致下边环境变量配置成功之后，还是不能使用maven的终端命令mvn。</strong></p><ul><li><code>bin</code>包含有操作maven的指令和命令的</li></ul><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>打开用户下配置环境变量的文件<code>.bash_profile</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">vi</span> ~/.bash_profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将以下配置存放至文件中</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> MAVEN_HOME<span class="token operator">=</span>/usr/local/apache-maven-3.6.3<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">${PATH}</span><span class="token keyword">:</span><span class="token variable">${MAVEN_HOME}</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>保存成功后，在执行如下配置，让配置生效</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">source</span> ~/.bash_profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mac用户配置类似mysql或者java的环境变量都可参照<strong>配置环境变量</strong>这个模块</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在终端使用mvn -v显示zsh: command not found: mvn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://maven.apache.org/download.cgi&quot;&gt;maven官网&lt;/a&gt;下载
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://lishengqi.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="maven" scheme="http://lishengqi.gitee.io/tags/maven/"/>
    
      <category term="Mac" scheme="http://lishengqi.gitee.io/tags/Mac/"/>
    
      <category term="环境变量" scheme="http://lishengqi.gitee.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac下配置NexT主题</title>
    <link href="http://lishengqi.gitee.io/posts/63598.html"/>
    <id>http://lishengqi.gitee.io/posts/63598.html</id>
    <published>2020-08-02T15:03:39.000Z</published>
    <updated>2020-08-19T13:12:14.069Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;详细内容请看 <strong><a href="https://theme-next.iissnan.com/">NexT官网文档</a></strong></p><ul><li><p><strong>&lt;blog name&gt;/_config.yml：<font color="Lightblue">站点配置文件</font></strong></p></li><li><p><strong>themes/next/_config.yml：<font color="pink">主题配置文件</font></strong></p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><table><tbody><tr><td bgcolor="lightblue"><strong>注意⚠️：查看NexT的Github仓库 <a href="https://github.com/theme-next/hexo-theme-next">hexo-themes-next</a> 确定NexT主题的克隆地址是否正确。</strong></td></tr></tbody></table>* **使用Git安装**  将NexT主题克隆到themes/next中<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/theme-next/hexo-theme-next.git themes/next <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>修改站点配置文件</strong> 注意next内容前面需要使用空格隔开，hexo可能会识别不到</li></ul><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">theme</span><span class="token punctuation">:</span> next<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>设置更多精彩样式请看 <a href="https://jrbcode.gitee.io/posts/63c4b34f.html">CodeHeap-快速使用Hexo搭建个人博客</a></strong> </p><ul><li>启动项目</li></ul><pre class="line-numbers language-bash"><code class="language-bash">$ hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看  <strong><a href="http://localhost:4000/">localhost:4000</a></strong>  </li></ul><h3 id="NexT主题优化"><a href="#NexT主题优化" class="headerlink" title="NexT主题优化"></a>NexT主题优化</h3><h4 id="设置背景"><a href="#设置背景" class="headerlink" title="设置背景"></a>设置背景</h4><ul><li>在主题配置文件中搜索<code>custom_file_path</code>，在<code>source/_data</code>下创建<code>styles.styl</code>。添加以下代码</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">// 添加背景图片body </span><span class="token punctuation">{</span>      <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url(/images/images.jpeg)</span><span class="token punctuation">;</span>//自己喜欢的图片地址      <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>      <span class="token property">background-repeat</span><span class="token punctuation">:</span> no-repeat<span class="token punctuation">;</span>      <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>      <span class="token property">background-position</span><span class="token punctuation">:</span> <span class="token number">50%</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//博客内容透明化//文章内容的透明度设置<span class="token class">.content-wrap</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0.85</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//侧边框的透明度设置<span class="token class">.sidebar</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0.85</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//菜单栏的透明度设置<span class="token class">.header-inner</span> </span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">0.85</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//搜索框（local-search）的透明度设置<span class="token class">.popup</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0.85</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.post</span> </span><span class="token punctuation">{</span>   <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>   <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>   <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">25</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><ul><li>在主题配置文件中搜索<code>avatar</code></li></ul><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">avatar</span><span class="token punctuation">:</span>  <span class="token key atrule">url</span><span class="token punctuation">:</span> /images/avatar.gif  <span class="token key atrule">rounded</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># 如果为true，则图片为正方形，头像将显示为圆形。为长方形，头像显示椭圆</span>  <span class="token key atrule">rotated</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># 如果为true，则头像将随着光标旋转。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置评论"><a href="#配置评论" class="headerlink" title="配置评论"></a>配置评论</h4><ol><li>配置Hexo NexT Utteranc <strong>详细内容请查看 <a href="https://github.com/theme-next/hexo-next-utteranc">Hexo NexT Utteranc配置</a></strong></li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> theme-next/hexo-next-utteranc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>安装成功后，在主题配置文件中配置，根据<code>username/username.github.io</code>配置repo，其他可按默认配置</li></ol><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Demo: https://utteranc.es/ http://trumandu.github.io/about/ </span><span class="token key atrule">utteranc</span><span class="token punctuation">:</span>   <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true </span>  <span class="token key atrule">repo</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#Github repo such as :TrumanDu/comments #根据username/username/github.io配置 </span>  <span class="token key atrule">pathname</span><span class="token punctuation">:</span> pathname <span class="token comment" spellcheck="true"># theme: github-light,github-dark,github-dark-orange </span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>light   <span class="token key atrule">cdn</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//utteranc.es/client.js   <span class="token comment" spellcheck="true"># If you want to modify priority, please config in **hexo** </span>  <span class="token comment" spellcheck="true">#priority:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>安装utterances。打开 <a href="https://github.com/apps/utterances">utterances</a>，点击Install，<code>Select repositories</code>选择自己搭建博客的仓库。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghek7f2842j31dg0mu7rg.jpg" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><strong>配置更详细更好看的NexT主题请查看 <a href="https://jrbcode.gitee.io/posts/63c4b34f.html">CodeHeap-快速使用Hexo搭建个人博客-主题美化</a></strong> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;详细内容请看 &lt;strong&gt;&lt;a href=&quot;https://theme-next.iissnan.com/&quot;&gt;NexT官网文档&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="博客搭建" scheme="http://lishengqi.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Mac" scheme="http://lishengqi.gitee.io/tags/Mac/"/>
    
      <category term="NexT" scheme="http://lishengqi.gitee.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo搭建个人博客</title>
    <link href="http://lishengqi.gitee.io/posts/42500.html"/>
    <id>http://lishengqi.gitee.io/posts/42500.html</id>
    <published>2020-08-02T06:08:09.861Z</published>
    <updated>2020-08-18T03:06:33.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>前言：最近自己用markdown写了一些博客，想着把自己写的东西也放在Github上。然后……自己的博客搭建了三天才完成。这过程也是蛮丰富的，一步一个脚印，一步一个坑啊。我把自己遇到的比较烦人的问题记下来，方便自己也方便大家</strong> </p></blockquote><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol><li><p><strong>Git</strong></p><p>查看电脑是否安装Git。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示以下代码证明系统上安装Git</p><pre class="line-numbers language-bash"><code class="language-bash">用法：git <span class="token punctuation">[</span>--version<span class="token punctuation">]</span> <span class="token punctuation">[</span>--help<span class="token punctuation">]</span> <span class="token punctuation">[</span>-C <span class="token operator">&lt;</span>path<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-c <span class="token operator">&lt;</span>name<span class="token operator">>=</span><span class="token operator">&lt;</span>value<span class="token operator">></span><span class="token punctuation">]</span>           <span class="token punctuation">[</span>--exec-path<span class="token punctuation">[</span><span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--html-path<span class="token punctuation">]</span> <span class="token punctuation">[</span>--man-path<span class="token punctuation">]</span> <span class="token punctuation">[</span>--info-path<span class="token punctuation">]</span>           <span class="token punctuation">[</span>-p <span class="token operator">|</span> --paginate <span class="token operator">|</span> -P <span class="token operator">|</span> --no-pager<span class="token punctuation">]</span> <span class="token punctuation">[</span>--no-replace-objects<span class="token punctuation">]</span> <span class="token punctuation">[</span>--bare<span class="token punctuation">]</span>           <span class="token punctuation">[</span>--git-dir<span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--work-tree<span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--namespace<span class="token operator">=</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token punctuation">]</span>           <span class="token operator">&lt;</span>command<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>args<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过homebrew安装Git，如未安装homebrew，安装命令如下</p><pre class="line-numbers language-bash"><code class="language-bash">$ /usr/bin/ruby -e <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装Git</p><pre class="line-numbers language-bash"><code class="language-bash">$ brew <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>Node.js</strong></p><p>安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ brew <span class="token function">link</span> node$ brew uninstall node$ brew <span class="token function">install</span> node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>验证Node是否安装成功：</p><pre class="line-numbers language-bash"><code class="language-bash">$ node -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装成功，显示node版本号</p></li></ol><img src="https://s1.ax1x.com/2020/08/03/adeqP0.jpg" style="width:738px;margin-left:2.2em"><h3 id="新建一个Github仓库"><a href="#新建一个Github仓库" class="headerlink" title="新建一个Github仓库"></a>新建一个Github仓库</h3><ol><li>如下图在Github上创建</li></ol><img src="https://s1.ax1x.com/2020/08/03/adMDAJ.jpg" style="width:738px;margin-left:2em;box-shadow: 1px 1px 10px rgba(0,0,0,.5)"><ol start="2"><li><p>创建ssh key，配置git</p><p>设置user.name和email(每次提交代码都会记录)</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"Github账户"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"Github注册邮箱"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用终端命令创建ssh key。创建过成功「三次回车」</p><pre class="line-numbers language-bash"><code class="language-bash">$ ssh-keygen -t rsa -C <span class="token string">"Github注册邮箱"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建成功之后，会/Users/“username”/.ssh下生成id_rsa.pub。复制id_rsa.pub文件的代码。</p><p>根据：Github用户下 -&gt; Settings -&gt; SSH and GPG keys -&gt; 点击New SSH key。粘贴至key中</p></li></ol><img src="https://s1.ax1x.com/2020/08/03/ad8VQ1.jpg" style="width:738px;margin-left:2em;box-shadow: 1px 1px 10px rgba(0,0,0,.5)"><h4 id="访问不到username-github-io"><a href="#访问不到username-github-io" class="headerlink" title="访问不到username.github.io"></a>访问不到username.github.io</h4><p>​    使用 <strong><a href="https://app.clash.cat/#">凡云</a></strong> 进行访问。具体操作需要进行注册登录，感兴趣的可以试试看。根据网站中的 <strong>"下载和教程"</strong> 进行安全上网</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul><li><p>详细内容请查看<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><p><strong>安装Hexo</strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>初始化项目</strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ hexo init blog$ <span class="token function">cd</span> blog$ <span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>启动项目</strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ hexo s <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<a href="http://localhost:4000/">localhost:4000</a>查看。显示网页则本地博客搭建</p><p>在站点配置文件 <code>……/blog/_config.yml</code>中搜索 <code>deplay</code>。将这部分的代码改成以下</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repository</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>username/username.github.io.git //使用ssh方式访问Git仓库  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>部署项目</strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ hexo g$ hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>部署成功，访问<code>username.github.io</code>就能查看本地项目的博客样式</strong></p><img src="https://s1.ax1x.com/2020/08/03/ad68UJ.jpg" style="width:738px;margin-left:1px;box-shadow: 1px 1px 10px rgba(0,0,0,.5)"></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://jrbcode.gitee.io/posts/63c4b34f.html">CodeHeap-快速使用Hexo搭建个人博客</a> 搭建过程很细节，样式涉及比较多，也很丰富</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;前言：最近自己用markdown写了一些博客，想着把自己写的东西也放在Github上。然后……自己的博客搭建了三天才完成。这过程也是蛮丰富的，一步一个脚印，一步一个坑啊。我把自己遇到的比较烦人的问题记下来，方便自己也方便大家&lt;/st
      
    
    </summary>
    
    
      <category term="博客搭建" scheme="http://lishengqi.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Mac" scheme="http://lishengqi.gitee.io/tags/Mac/"/>
    
      <category term="Hexo" scheme="http://lishengqi.gitee.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
